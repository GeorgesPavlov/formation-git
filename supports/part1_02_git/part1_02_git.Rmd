---
title: "Utiliser GIT avec R à l'Insee"
subtitle: "Travail collaboratif avec R"
author: "Mathias ANDRE"
date: "`r format(Sys.Date(), format = '%d %B %Y')` "
output: collaboratif_format
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```


# Pourquoi utiliser la gestion de version ?

Nos travaux statistiques évoluent constamment (productions annuelles, nouvelles enquêtes, etc.) et nous travaillons souvent à plusieurs. En outre, le maintien de la qualité de nos chaînes de traitement nécessitent un archivage détaillé et facilement accessible. 

Tous les statisticiens se sont déjà demandé (ou à leurs collègues) : 

* quelle était la bonne version d'un programme 
* qui était l'auteur d'un bout de code en particulier
* si un changement était important ou juste un essai
* comment fusionner des programmes
* etc.

**Exemple d'une organisation de fichiers à l'ancienne**
![](./pics/fichiers_multiples.png){width=100%}  

Il existe un outil informatique puissant afin de répondre à tous ces besoins : la gestion de version (*version control system* (VCN) en anglais). Ses avantages sont incontestables et permettent de facilement :

* enregistrer l'historique des modifications d'un ensemble de fichiers 
* revenir à des versions précédentes d'un ou plusieurs fichiers
* rechercher les modifications qui ont pu créer des erreurs
* partager ses modifications et récupérer celles des autres
* proposer des modifications, les discuter, sans pour autant modifier la dernière version existante
* identifier les auteurs et la date des modifications

En outre, ces outils fonctionnent avec tous les langages informatiques (texte, R, Python, SAS, LaTeX, Java, etc.) car reposent sur la comparaison des lignes et des caractères des programmes.

## Conserver et archiver du code

Une des principales fonctionnalités de la gestion de version est conserver l'ensemble des fichiers de façon sécurisée et de proposer un archivage structuré des codes. Les fichiers sont stockés dans un **dépôt**, qui constitue le projet (par exemple, le modèle Ines).

Tout repose dans la gestion et la présentation de l'historique des modifications. Chaque modification (ajout, suppression ou changement) sur un ou plusieurs fichiers est identifiée par son auteur, sa date et un bref descriptif. Chaque changement est donc unique et aisément identifiable quand ils sont classés par ordre chronologique. Les modifications transmises au dépôt sont appelées **commit**.

**Un exemple d'historique d'un projet sur GitLab**
![histoGIT](./pics/historique_gitlab.png){width=100%}  

**Un exemple d'historique d'un projet via RStudio**
![histR](./pics/historique_Rstudio.png "texte pour le titre, facultatif"){width=100%} 

Sur son poste de travail, les dizaines (centaines ?) de programmes organisés à la main n'existent plus. Tout est regroupé dans un seul dossier, rassemblant les éléments du dépôt. Au sein du dépôt, tout l'historique est stocké et accessible rapidement. Si on souhaite travailler sur la dernière version des programmes (ou sur une ancienne version spécifique), il n'y a plus besoin de conserver les autres fichiers car ils sont dans l'historique du projet. Il est alors possible de choisir sur quelle version on veut travailler (la dernière commune à tout le monde, la sienne en train d'être développée, celle de l'année dernière, etc.).

## Travailler efficacement en équipe

Le deuxième avantage de la gestion de version représente une amélioration notable du travail en équipe sur des codes en commun. Que ce soit au sein d'un modèle cogéré (Ines, Destinie, etc.), de gros projets (Nautile) ou de chaînes de traitement récurrentes (enquête emploi, comptes trimestriels, etc.), la collaboration est courante lors des travaux statistiques. La gestion de version permet collaborer simplement et avec méthode. De façon organisée, elle permet de:

* travailler en parallèle et fusionner facilement du code
* partager une documentation des programmes grâce :
    + aux commentaires des modifications
    + à la possibilité d'une documentation commune et collaborative
* trouver rapidement des erreurs et en diffuser rapidement la
correction

**Exemple de détails d'une modification**
![](./pics/commit_Rstudio.png){width=100%} 

L'usage individuel, c'est-à-dire seul sur son projet, permet aussi de "travailler en équipe avec soi même" car il permet de retrouver des mois plus tards le contenu et le contexte des modifications. Cela est notamment précieux lors des changements de poste ou des travaux réguliers mais espacés dans le temps (par exemple, un mois par an chaque année).


## Améliorer la qualité des codes

Le fonctionnement du gestion de version, reposant sur l'archivage structuré des modifications et les commentaires les accompagnant, renforce la qualité des programmes informatiques. Ils sont plus documentés, plus riches et mieux structurés. 

Quand il s'agit de modèles statistiques, ou de chaînes de traitement statistique, constitués de nombreux programmes, la gestion de version permet :

* l'amélioration la qualité des modèles par des méta-données riches, 
* un gain de place pour stocker les historiques
* leur diffusion simplifiée et harmonisée. 

Lors de l'ouverture des modèles, leur diffusion publique correspond aux standards des communautés de logiciels libres et aux usages recommandés pour documenter des programmes informatiques. Cela permet aux utilisateurs ou aux agents découvrant des chaînes de traitement de mieux s'approprier les programmes.

## Usage quotidien : un exemple avec le modèle Ines

Le modèle Ines est co-développé par l'Insee et la Drees ainsi que la Cnaf depuis 2018. Sous licence libre, il est disponible en *open-source*. Il est organisé dans une forge qui regroupe le code, un wiki, une documentation, un forum et différents outils collaboratifs. Les utilisateurs y ont accès via la [plateforme Adullact](https://adullact.net/projects/ines-libre). Le dépôt regroupe donc les programmes, l'historique des modifications et les archives des différentes versions ('Ines 2018' par exemple).

Les chargés d'étude ont une copie locale du projet sur leur poste de travail. Les changements sont mis à jour et disponible en temps réel.

**Envoi d'une modification avec TortoiseSVN : commit**

![](./pics/commit_Ines.png){width=100%}   

**Historique d’un fichier ou dossier : log**
![](./pics/historique_Ines.png){width=100%}  

**Recherche efficace une erreur : blame**
![](./pics/blame_ines.png){width=100%}  


## Avec ou sans gestion de versions

Le tableau suivant compare les usages au temps (pré-historique ?) de la programmation sans gestion de version avec les modes de travail si on y a recours.

|                      |      Avant            |  Gestion de version  |
|:---------------------|----------------------:|---------------------:|
|Archivage             | à la main             | automatique          |
|Envoi de modification | mail, dossier partagé | code partagé         |
|Fusion de code        | copié-collé           | simple, sûr          |
|Versions du modèle    | dossiers archivés     | historique riche     |
|Gestion des erreurs   | à la main             | méthodique           |
|

En conclusion, que ce soit au sein d'un travail collaboratif en équipe ou sur ses propres projets individuels, notre temps est consacré à la programmation réellement utile. L'organisation du travail est efficace grâce :

* aux améliorations rapides des codes
* au partage efficace des tâches
* à la recherche puissante des erreurs
* à un archivage géré automatiquement avec des méta-données
* à des outils généralisés et documentés en ligne.

La gestion de version est donc le meilleur moyen de partager du code (entre équipes internes,
lors des changements de poste, pour l'archivage, lors de l'ouverture au libre, etc.). Ces outils viennent de l'informatique et de la création des logiciels et applications. Les traitements statistiques sont également des chaînes informatiques et sont donc pleinement adaptés pour être traités avec les outils de gestion de version.

# Des bases de GIT 

Les deux langages de gestion de version les plus répandus sont GIT et SVN. L'Insee a utilisé SVN pendant un temps mais privilégie GIT maintenant, en raison de plusieurs avantages. 

GIT est un logiciel qui est installé sur son poste et celui de ses collaborateurs. Il est open source, gratuit et très répandu. Ainsi, une vaste documentation est disponible en ligne ou les forums d'entraide de type 'stackoverflow' (voir par exemple le tag ['GIT'](https://stackoverflow.com/questions/tagged/git) ). Sur la plateforme 'github', la (page de tutoriel)[http://try.github.io/] regroupe différents supports. Des vidéos pédagogiques sont fournies sur (git-scm.com)[https://git-scm.com/videos]

Cependant, face au foisonnement des pratiques et des ressources en ligne, il est recommandé d'adopter et suivre les donnes pratiques pour chaque projet. Les configurations et les habitudes diffèrent et une solution proposée sur un forum ou dans un livre peut ne pas être adaptée dans notre cas précis. C'est l'objectif de ce support de rassembler les pratiques les plus courantes et présenter l'utilisation recommandée de la gestion de version avec R studio à l'Insee.

La genèse de Git correspond au noyau du système d'exploitation Linux qui gérait les patchs et les archives pendant les années 1990. À partir de 2005, Linus Torvalds, aussi inventeur de Linux, développe un successeur avec pour objectifs, la vitesse, la simplicité, la possibilité de développements en parallèle (les futures **branches**), le tout avec un usage compact des données. Depuis, son usage a largement dépassé celui de SVN.

SVN est dit centralisé alors que GIT est dit distribué. Cela signifie notamment que chaque collaborateur possède une copie en propre de l'ensemble du projet sur son poste de travail. Cela implique un avantage important de GIT en terme de sécurité des codes (qui risquent beaucoup moins d'être perdus) et la  rapidité des partages des modifications. En outre, contrairement à SVN pour lequel il faut être connecté à un serveur, il n'est pas besoin d'être connecté avec GIT et on peut travailler en local. Ainsi, on transmet ses modifications quand on le souhaite ou peut et cela facilite le travail distant.

Enfin, un des grands avantages pratiques de GIT est son intégration naïve dans l’interface RStudio ainsi que dans les plateformes de forme Github et Gitlab (voir parties ci-après). À l'origine utilisé en ligne de commandes (et utilisé comme tel par les développeurs), les interfaces graphiques actuelles permettent de s'en passer dans l'immense majorité des situations.


## Le B.A-BA

Les programmes s’organisent sur un répertoire distant commun
(dépôt ou **repository**) et sont manipulés sur les postes indidivuels dans des
dossiers locaux (**working directory**). Le dépôt peut par exemple être hébergé sur une plateforme de type **GitLab**.

Les trois manipulations les plus courantes sont les suivantes et représentées sur le diagramme ci-après : 

+ `pull` : je récupère la dernière version des codes du dépôt distant
+ `commit` : je valide mes modifications avec un message qui les expliquent
+ `push` : je transmets mes modifications validées au dépôt distant


![](./pics/push_pull_Drees.png){width=100%} 

De manière plus précise, il y a trois étapes avant d'envoyer les modifications validées (commit) au dépôt. Elles se définissent en fonction des commandes qui permet de les appliquer quand Git est utilisé en ligne de commandes :

* `diff` : inspection des modifications. Cela permet de comparer les fichiers modifiés et de distinguer les fichiers ajoutés ou supprimés
* `staging area` : sélection des modifications 
* `commit` :  validation des modifications sélectionnées (avec commentaire).

Les deux diagrammes ci-dessous représentent ces différences étapes et les commandes qui permet de passer d'un état à l'autre.

![](./pics/trois_états_fichier.png){width=100%} 

![](./pics/statut_fichiers.png){width=100%} 
Lors d'un 'commit', le message de validation est très important.
– décrit brièvement les modifications contenues dans le commit
– importance de l’homogénéité des modifications contenues dans un commit
– à l’attention des autres développeurs

Chaque commit est identifié de façon unique par un **hash**, c'est ce qui permet les différentes manipulations.

Ensuite, les deux fonctions 'push' et 'pull' permettent la mise à jour du local par rapport au distant et réciproquement. Lors de ces étapes des **conflits** peuvent exister, c'est par exemple le cas lors que deux personnes ont modifié le même programme simultanément. 

Tout d'abord, il est possible de minimiser l'apparition de conflits en amont en validant souvent les modifications ('commit') :

* par petits lots homogènes et en préférant peu de fichiers
* en communiquant avec les autres membres de l’équipe en disant sur quoi on travaille et en prévenant en cas de grosse modification
* Mettre à jour sa copie locale régulièrement via 'pull', voire dès qu'on commencer à travailler sur un projet.

De manière générale, il ne faut pas avoir peur des conflits. Les outils sont faits pour les gérer avec rigueur et méthode (voir EXERCICE). Avec 'GIT', il est très rare de faire des bétises et on peut toujours réparer. Mais il n'est justement pas recommandé d'utiliser les commandes de la forme 'git push --force'. 

## Les branches

C'est une des fonctionnalités les plus pratiques de la gestion de version. La création de branches dans un projet (qui devient ainsi un arbre) permet de développer en parallèle des correctifs ou une nouvelle fonctionnalité sans perturber le dépôt commun. Cela permet de séparer le nouveau développement et de faire cohabiter plusieurs versions, pouvant évoluer séparément ou pouvant être facilement rassemblées. Git est optimisé pour le travail sur les branches.

Les branches peuvent avoir des durées de vie plus ou moins longues selon leurs objectifs : nouvelle fonctionnalité, résolution de bugs, environnement de développement ou de production, etc.

Trois principales fonctionnalités existent :

* `git branch` : création d'une branche
* `git checkout` : pour changer de branche
* `git merge` : fusion de branche

Dans un projet collaboratif, une branche dite **master** joue le rôle du tronc. C'est autour d'elle que vont pousser ou se greffer les branches comme le montre l'exemple ci-dessous.

![](./pics/branches_tree.png){width=100%} 

## Quelques compléments de GIT 

Le langage GIT permet un grand nombre de fonctionnalités avancées. Les manipulations les plus complexes ne peuvent être effectuées qu'en ligne de commande, mode de fonctionnement privilégié des développeurs avancés. Mais pour les statisticiens, il est possible d'effectuer des commandes avancées de façon intégrée.

Une des commandes les plus utiles pour un travail collaboratif pour les statisticiens permet de ne pas partager les bases de données ou tout type de fichier, soit trop volumineux, soit confidentiel : 

* `git ignore` : modifier le fichier permet de conserver des fichiers en privé, c'est-à-dire qu'ils n'apparaissent pas dans le dossier partagé. 

Ainsi, il est crucial de ne pas partager les données et exclure les fichiers de la forme `*.csv` ainsi que tous les fichiers de sortie, notamment au format `*.html` ou `*.pdf`.

La Cnil fournit ainsi des conseils aux développeurs pour compléter ces bonnes pratiques : https://linpricnil.github.io/Guide-RGPD-du-developpeur/ 

D'autres fonctionnalités plus avancées existent et pourront être mises à profit si elles sont correctement utilisées: 

* `git tag` : sauvegarder une version figée, comme une "photographie" à un instant donné
* `git blame` : lister les modifications d'un fichier donné à une ligne donnée

Le `git blame` permet ainsi de filtrer sur les différences précédentes afin de régler des problèmes ou trouver un commit particulier à l'origine d'un bug ou d'une erreur. `git log` peut aussi permettre de filtrer les contenus des différences pour rechercher le commit à l'origine d'un changement en particulier.


D'autres commandes, plus périlleuses peuvent permettre un retour en arrière dans l'historique, appelé rebasage. La réécriture de l'historique est un usage non recommandé pour une utilisation non approfondie comme un projet statistique en équipe. En cas de manipulations s'écartant des sentiers battus, il est toujours possible de revenir à des sauvegardes manuelles des fichiers et à des déplacements par copié-collé des programmes à modifier ou à récupérer.

Pour aller plus loin, des ressources internes existent (plutôt destinés à des développeurs) :

* [`GIT` au quotidien](https://romain-warnan.github.io/git-au-quotidien) par Romain Warnan  
* des supports du SNDI sur les [bases de `GIT`](http://formation-git-sndi-lille.pages.innovation.insee.eu/cours/#/)

Les ressources externes très complètes sont disponibles, citons notamment un [livre en français](https://git-scm.com/book/fr/v2) accessible en ligne et la [documentation en ligne](https://git-scm.com/doc) de `GIT`.


## Vocabulaire 

En résumé, voilà les principaux concepts présentés et qui seront utiles pour la pratique de la gestion de version :

`repository` : le dossier partagé qui contient toutes les informations

`commit` : modification validée à un instant donné, par extension l'état du projet à cet instant

`hash` : un identifiant unique pour chaque commit, contenant notamment l'horodatage

`checkout` : un déplacement vers un commit

`branche` : un projet parallèle au sein du dossier

`merge` : la fusion de une ou plusieurs branches

`remote` : un serveur distant ayant une copie de repository

`clone` : récupération du dossier depuis le remote (pour la première fois)

`pull` : récupération des nouveaux commits en local depuis le remote

`push` : envoi de ses nouveaux commit vers le remote

# Gitlab, aperçu de la plateforme de partage de code 

Gitlab est une plateforme facilitant l’utilisation de git, qui permet de travailler de façon collaborative dans le développement informatique, par équipe ou non, pour un code qui évolue constamment. Un réseau social du code

Principales fonctionnalités :

Inspecter un dépôt distant : onglet branches, commits etc

[documentation](https://docs.gitlab.com/ee/user/index.html)  `GitLab`

cf. Drees : groupes publics et privé, profils, pages projet etc.

![](./pics/page_Drees_gitlab.png){width=100%} 

![](./pics/projet_gitlab.png){width=100%} 

* Explorations du code

* Tickets

* Fusion de branches : MR et merge en pratique (exemples des PR avec commentaires etc.)

 à éviter pour un usage néophyte :  à éviter pour un usage néophyte
 si vous avez peur de faire une bêtise, commencez par faire une copie locale de votre clone

rebase
push force

# Configurer un projet `GIT` avec Rstudio à l'Insee

Dans une configuration classique, la première étape constisterait à installer le logiciel `GIT` sur son poste. C'est par exemple le cas sur son ordinateur personnel ou sur son poste de travail. Cependant, cette formation adopte un cadre de travail sécurisé et partagé, permettant à la fois d'utiliser la version de `Rstudio` recommandée et d'avoir accès aux coffres. Elle se déroulera donc sur le serveur de calcul `AUS`. Il est également possible de collaborer à des projets via son poste local. Nous présentons cette configuration dans un premier temps.

La seconde brique afin de pouvoir travailler sur un projet partagé est le choix de la plateforme où est stocké le `repository`. Cela peut être sur `GitHub.com`, `GitLab.com` ou une autre forge en ligne. À l'Insee, il est recommandé de s'appuyer sur la [plateforme innovation](https://onyxia.beta.innovation.insee.eu/accueil) qui héberge un [`GitLab` interne](https://git.stable.innovation.insee.eu/).

Il est d'abord nécessaire de créer son accès à la plateforme et ensuite de configurer l'acccès au `GitLab`. Ces manipulations sont à faire une seule fois pour un poste de travail. Ensuite, les manipulations pour accéder à un projet déjà existant sont plus simples. C'est l'étape fondamentale pour pouvoir lire et modifier un dossier partagé.

## La première fois 
### Accéder au `GitLab` de la plateforme

Le `GitLab` est accessible via ce lien : [git.stable.innovation.insee.eu/](https://git.stable.innovation.insee.eu/). Après avoir créé un compte sur la plateforme en y accédant pour la première fois, il est nécessaire de se connecter avec son profil individuel. Pour y accéder, il suffit de cliquer sur `Sign In` en haut à droite: 

![](./pics/sign_in_gitlab.png){width=100%} 

L'authentification sur la plateforme est alors automatique depuis le poste de travail Insee via le login `Insee SSO`. Il suffit alors de cliquer pour être connecté en tant qu'utilisateur:

![](./pics/login_sso.png){width=100%} 

### Générer et ajouter une clé SSH

La deuxième étape pour mener à bien la configuration initiale revient à permettre le dialogue entre la plateforme (ici `GitLab`) et le logiciel `GIT` en local. Pour ce faire, le contrôle de version repose sur un protocole sécurisé, chiffrant les échanges. Ce processus d'authenfication s'appuie sur les clés SSH, l'une publique qu'on envoie à la plateforme distante, l'autre privée que l'on conserve sur son poste. C'est la combinaison des deux qui identifie un utilisateur de façon unique et sécurise les échanges. Un utilisateur peut générer autant de clés SSH qu'il souhaite, par exemple pour échanger avec plusieurs systèmes distants.

Il est d'abord nécessaire de télécharger des utilitaires  via l'application `Si@moi`, et de suivre le chemin suivant : "Faire une demande" > "Catalogue à l'usage de tous les agents" > "3 Installation de logiciels" > Rubrique "Développement" > "Git Pack".

Ensuite, le logiciel "Paramétrage SSH" permet de créer une clé sur son poste local :

![](./pics/ssh_keygen.png)

On sélectionne ensuite "Générer une nouvelle clé" ; cette clé sera créée et sauvegardée en général dans le chemin suivant : D:/idep/Données d'application/.ssh, et sera constituée de deux fichiers texte :

* un fichier en .pub, qui fournit la partie publique de la clé, et qui a vocation à être diffusée (donc c'est ce fichier qu'on chargera sur `Gitlab` pour permettre l'authentification) ;
* un fichier .ppk (comme Private Key) qui est la partie privée de la clé, et qui ne doit en aucun cas être diffusée.

L'outil propose ensuite de télécharger la partie publique de la clé sur un dépôt distant à spécifier ; un message d'erreur s'affiche dans certains cas mais il ne faut pas s'y fier. Nous allons confirmer manuellement après l'accès à `GitLab`. Enfin, l'outil propose de configurer l'utilitaire `Putty` (que Git utilise pour générer une connexion sécurisée entre le dépôt distant et le dépôt local) ; il faudra renseigner les éléments suivants :

* Identifiant : idep de l'utilisateur
* Hôte : gitlab.stable.innovation.insee.eu
* Port : 22222

Il faut ensuite charger la clé dans le cache de `Putty` ; pour cela, il faut ouvrir `Putty` (dans Menu Démarrer > Tous les programmes > INSEE atelier de développement V2 > utilitaire > putty), sélectionner "gitlab.stable.innvation.insee.eu", "Load", "Open". Le système renvoie une erreur, mais la clé est normalement chargée dans le cache, il reste à configurer Gitlab pour que ce dernier reconnaisse la clé SSH comme étant celle de l'utilisateur.

Pour ce faire, il est nécessaire de retourner sur les paramètres du profil sur `Gitlab` et accéder aux réglages de l'espace personnel : 

![](./pics/setting_ssh.png)

En sélectionnant `SSH Keys` dans le bandeau latéral gauche, il faut copier-coller dans la fenêtre le texte du fichier `.pub` de la clé SSH (en veillant à ne pas laisser l'éventuel texte en fin du type `imported-openssh-key`).

![](./pics/ssh_copy_key.png)

Après avoir cliqué sur le bouton `Add Key` et en modifiant éventuellement le `Title` (nom de la clé), `GitLab` est configuré et il est possible d'échanger avec `GIT` en local. La [documentation de la plateforme Innovation](http://innovation.pages.innovation.insee.eu/documentation-plateforme-innovation/gitlab/clef-ssh/) détaille également la procédure pour l'ajout d'une clé SSH.

## Au lancement de chaque projet 

Cloner un dépôt à partir de GitLab

vidéo installation du SNDI : http://formation-git-sndi-lille.pages.innovation.insee.eu/installation-git/ 

configuration GIT  :https://git.stable.innovation.insee.eu/formation-git-sndi-lille/installation-git

remote SSH via la plateforme innovation sur AUS.

## D'autres possibilités pour des projets externes

En cas de collaboration avec des personnes extérieures ou pour des projets personnels non hébergés sur la plateforme innovation, il est possible de s'affranchir de la configuration d'une clé SSH. Le protocole d'échanges sécurisés s'appuie alors sur la technologie `https`.

Par exemple, en ayant un profil sur `github.com` ou `giltlab.com`, il suffit alors de copier l'url : 

![](./pics/clone_https.png)

et d'indiquer à `Rstudio` comment s'y connecter. Dans "File / New Project", sélectionner `Version control` puis `GIT` :  

![](./pics/Rproj.png)

Il suffit ensuite de remplir les trois paramètres : 

* *Repository URL* : coller l'adresse `https` copiée depuis la plateforme.
* *Projet directory name* : le nom du dossier où va sera la copie locale du `repository`, c'est là où vous allez modifier les programmes et où se situera votre code
* *Create project as subdirectory of* : le chemin physique où se situera le projet, par exemple `D:/idep`.

Cliquer sur `Create project` copier les fichiers du dossier partagé et vous permet de travailler sur `Rstudio` avec l'interface `GIT` qui va être décrite dans la partie suivante.

# Bonnes pratiques de `GIT` et `GitLab` 

Dans cette partie, nous allons adopter un fil rouge en créant un document collaboratif commun et en pratiquant par des exercices les principales situations d'un statisticien qui travaille avec R et GIT via RStudio et GitLab. 


## Pré-requis pour l'organisation du travail collaboratif

- vous devez identifier les responsables de la maintenance du projet. Dans `GitLab`, c'est facile, c'est le rôle de _Maintener_ (droits d'écriture sur `master`)
- chaque mainteneur a une responsabilité identique et élevée : n'accordez pas les droits de mainteneur sur votre repo à la légère, vous pourriez le regretter
- c'est au(x) mainteneur(s) du repo de définir les règles d'organisation du travail
- idéalement, ces règles doivent être précisément décrites dans un fichier nommé `CONTRIBUTING.md` placé à la racine du projet
- il est essentiel que chaque personne qui contribue au projet se conforme à ces règles
- `git` est un outil extrêmement puissant et flexible, adaptable à tout type d'organisation du travail. Dès lors, les problèmes que vous rencontrerez ne seront pas liés à `git` mais à une mauvaise définition de l'organisation du travail ou bien à son non respect par les mainteneurs. 
- d'expérience, si vous n'avez pas réfléchi à l'organisation du travail, il est à peu près certain que vous rencontrerez des problèmes. Des difficultés peuvent en particulier apparaître dans une équipe dont personne n'aurait d'expérience avec `git`
- vous devez savoir qu'il y a plusieurs méthodes de travail avec `git`. Vous pourrez trouvez des dizaines d'articles et d'ouvrages sur ce sujet dont chacun prétend avoir trouvé la meilleure organisation du travail. Ne lisez pas trop ces livres et articles sinon vous serez perdus (un peu comme avec les magazines destinés aux jeunes parents...)

Cependant, vous devez savoir que des "habitudes" se sont imposées dans la communauté R, essentiellement au travers des collaborations sur la plateforme GitHub (GitLab fonctionne de la même façon mais est open source contrairement à GitHub). Au fur et à mesure des collaborations, une forme de "norme sociale" s'est peu à peu imposée. Nous allons vous décrire ces habitudes. Cela vous donnera une première base, autant de points de repères. Vous pourrez ainsi contribuer à vos packages préférés sur GitHub. Au fur et à mesure de vos projets et quand vous aurez acquis une certaine maîtrise de `git`, vous adapterez certainement ces règles à vos besoins. Cela n'est absolument pas gênant... à partir du moment où vous comprenez ce que vous faites.


On propose une synthèse des usages de `git` dans la communauté R, adaptés à la configuration à l'Insee : AUS pour commencer (puis à la fin donner les autres usages.)

## GIT en local

Exercice : staging
Modifier un fichier

Exercice : commit
Valider cette modification dans votre dépôt local

Exercice : push
Envoyer cette modification au dépôt commun

Exercice : pull
Récupérer les modifications du dépôt commun

Exercice : branch
Créer une branche et la modifier.

Excercice : gitignore
Ajouter les fichiers .pdf etc. dans le gitignore

gitignore : pas les résultats (exemple des markdowns volumineux), pas les données, pas d'informations personnelles (configuration).
ce n'est pas un drive / dropbox.


Voici quelques usages couramment répandus, ceux qu'on observe le plus souvent. Nous ne prétendons pas que tout le monde respecte toutes ces règles mais voici les "patterns" fréquemment observés. Comme il a été indiqué, ces règles ne sont pas les "meilleures". Vous trouverez donc toujours quelqu'un pour indiquer que telle ou telle règle n'est pas nécessaire, qu'on peut faire autrement, qu'une autre est bien meilleure... 

Même si elles sont écrites de façon impérative, conservez du recul. Cependant, si vous les adoptez, tout se passera bien.

## Ouvrir et organiser les issues

Avant de travailler, vous devez ouvrir des issues. Au début de votre projet, ce seront des fonctionnalités (en anglais, _features_). Au bout d'un moment, vos issues seront également des bugs constatés.

Ces issues seront fermées au fur et à mesure que les fonctionnalités seront implémentées ou bien que vous aurez abandonné vos idées. Utilisez les labels pour classer vos issues. Vous pouvez les affecter à une personne en particulier, fixer une date de rendu, etc.

EXERCICE : ouvrir et assigner une issue à votre voisin. Répondre à celle de votre voisin et clore celle que vous avez initiée. 

## Le rôle de `master`

La branche `master` est la branche principale. Elle se doit d'être "propre". On ne pousse pas des travaux non aboutis sur `master`, c'est très mal vu. Avec l'intégration continue, elle se doit d'être en succès. 

Peut-on pousser directement sur `master` ? oui, pour des petites corrections, des modifications mineures dont vous êtes certains qu'elles vont fonctionner. Mais sachez que dans le cadre de projets sensibles, c'est strictement interdit. N'ayez pas peur de fixer comme règle l'interdiction de pousser sur master, cela obligera l'équipe projet à travailler très professionnellement (ça fera peut-être râler certains coéquipiers mais c'est pour la bonne cause).

Au moindre doute, créez une branche.

## Les branches

Les branches sont utilisées pour des travaux significatifs :

- vous travaillez seul sur une tâche qui va vous prendre plusieurs heures ou jours de travail (vous ne devez pas pousser sur master des travaux non aboutis)
- vous travaillez sur une fonctionnalité nouvelle et vous souhaiterez recueillir l'avis de vos collègues avant de modifier `master`
- vous n'êtes pas certain de réussir vos modifications "du premier coup"

**Toutes les branches sont publiées, le rebase est interdit. Le push force est également interdit.** (carton rouge)

**Tous les merges dans master doivent se faire par l'intermédiaire d'une merge request dans GitLab**. En effet, il est très mal vu de merger une branche dans master localement (carton rouge).

Comment nommer les branches ? Là encore, il y a énormément de conventions différentes. Une fréquemment observée est :

- pour les nouvelles fonctionnalités : `feature/nouvelle-fonctionnalite` où `nouvelle-fontionnalite` est un nom court résumant la fonctionnalité
- pour les corrections de bug : `issue-num` où `num` est le numéro de l'issue

N'hésitez pas à aller encore plus loin dans la normalisation : c'est pour la bonne cause !

EXERCICE : créer une branche avec votre voisin, commit, push, pull

## Ouvrir des merge requests

Les merges requests sont sans doute la fonctionnalité la plus pratique.

Vous ouvrez une merge request :

- donnez un titre explicite
- donnez des détails dans le message
- dans le corps du message, ajoutez `close #xx` où `xx` est le numéro de l'issue décrivant la fonctionnalité que la merge request implémente. Lorsque la merge request sera fusionnée, l'issue sera automatiquement fermée et un lien sera créé entre l'issue et la merge request. Cela vous permettra de comprendre, plusieurs mois ou années plus tard comment et pourquoi telle ou telle fonctionnalité à été implémentée

Une fois une merge request ouverte, sollicitez une relecture. En effet, personne (même les superstars de la programmation) n'est à l'abri d'une erreur. 

Les merge requests doivent également modifier le fichier `NEWS.md`, de la façon suivante :

```markdown
# Version 0.4

## Nouvelles fonctionnalités

- La fonction `show_map()` permet d'afficher une carte (#xx et !yy).

## Corrections de bugs

- La fonction `compute_map()` renvoie une erreur si la projection n'est pas Lambert-93 (#ww et #zz).
``` 

Dans l'exemple ci-dessus, les chiffres précédés de `!` font référence aux numéros des merges requests.  
Les chiffres précédés de `#` font références aux issues.

EXERCICE : créer une MR proprement avec GitLab (indications)

## Contribuer aux merge requests

**Les merge requests sont des espaces de discussion**. Vous pouvez commenter une proposition de modification en particulier ou bien suggérer une modification.

Lorsqu'elles sont acceptées, les suggestions sont appliquées au moyen d'un commit. Cela permet une parfaite traçabilité des modifications.

EXERCICE : Choisissez une autre MR et contribuez-y via GitLab.

## Fusionner les merge requests

C'est la responsabilité des mainteneurs : seuls les mainteneurs peuvent merger dans master. Il leur appartient de veiller à la bonne qualité des merge requests.

Question : squash and merge ou pas ?  
Là, vous devrez faire preuve de discernement. L'habitude est de faire des squash and merge (pratique la plus largement répandue). Cependant, il peut y avoir des cas où vous préférerez conserver l'historique des commits (c'est plus rare). Très franchement, ce sujet n'est pas le plus important.

## Résoudre les conflits

Si vous adoptez les règles précédentes, master sera surtout modifié via des merge requests. Vous ne devriez donc jamais avoir de conflits sur master.

Tous les conflits devraient donc survenir dans les branches. Les merge requests en conflit sont impossibles à merger. Il n'y a donc pas de possibilité de commettre un erreur par mégarde (c'est la raison pour laquelle il est interdit de merger dans master localement).

Si votre branche est en conflit, **le conflit doit être résolu dans la branche et pas dans master**. Voici la marche à suivre :

- appliquez le conseil de survie : faites une copie de sauvegarde de votre clone (avec l'expérience, vous pourrez vous passer de cette étape)
- dans votre clone, placez vous sur la branche en question `git checkout nom-de-la-branche`
- mergez master dans la branche `git merge master`
- résolvez les conflits
- finalisez le commit de merge
- poussez vers GitLab

Rappel : **Il est interdit de faire l'inverse (merger localement la branche dans master)**

Une référence sur GitHub : https://happygitwithr.com/ 

EXERCICE : ouvrir une MR, l'assigner, la résoudre sur GitLab
Usage des issues et ToDo

EXERCICE : comment on peut contribuer à un repo pour lequel on n'a pas les droits en écriture à l'aide d'un fork


    