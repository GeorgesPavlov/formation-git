---
title: "Utiliser GIT avec R à l'Insee"
subtitle: "Travail collaboratif avec R"
author: "Mathias ANDRE"
date: "`r format(Sys.Date(), format = '%d %B %Y')` "
output: collaboratif_format
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```


# Pourquoi utiliser la gestion de version ?

Nos travaux statistiques évoluent constamment (productions annuelles, nouvelles enquêtes, etc.) et nous travaillons souvent à plusieurs. En outre, le maintien de la qualité de nos chaînes de traitement nécessitent un archivage détaillé et facilement accessible. 

Tous les statisticiens se sont déjà demandé (ou à leurs collègues) : 

* quelle était la bonne version d'un programme 
* qui était l'auteur d'un bout de code en particulier
* si un changement était important ou juste un essai
* comment fusionner des programmes
* etc.

**Exemple d'une organisation de fichiers à l'ancienne**
![](./pics/fichiers_multiples.png){width=100%}  

Il existe un outil informatique puissant afin de répondre à tous ces besoins : la gestion de version (*version control system* (VCN) en anglais). Ses avantages sont incontestables et permettent de facilement :

* enregistrer l'historique des modifications d'un ensemble de fichiers 
* revenir à des versions précédentes d'un ou plusieurs fichiers
* rechercher les modifications qui ont pu créer des erreurs
* partager ses modifications et récupérer celles des autres
* proposer des modifications, les discuter, sans pour autant modifier la dernière version existante
* identifier les auteurs et la date des modifications

En outre, ces outils fonctionnent avec tous les langages informatiques (texte, R, Python, SAS, LaTeX, Java, etc.) car reposent sur la comparaison des lignes et des caractères des programmes.

## Conserver et archiver du code

Une des principales fonctionnalités de la gestion de version est conserver l'ensemble des fichiers de façon sécurisée et de proposer un archivage structuré des codes. Les fichiers sont stockés dans un **dépôt**, qui constitue le projet (par exemple, le modèle Ines).

Tout repose dans la gestion et la présentation de l'historique des modifications. Chaque modification (ajout, suppression ou changement) sur un ou plusieurs fichiers est identifiée par son auteur, sa date et un bref descriptif. Chaque changement est donc unique et aisément identifiable quand ils sont classés par ordre chronologique. Les modifications transmises au dépôt sont appelées **commit**.

**Un exemple d'historique d'un projet sur GitLab**
![histoGIT](./pics/historique_gitlab.png){width=100%}  

**Un exemple d'historique d'un projet via RStudio**
![histR](./pics/historique_Rstudio.png "texte pour le titre, facultatif"){width=100%} 

Sur son poste de travail, les dizaines (centaines ?) de programmes organisés à la main n'existent plus. Tout est regroupé dans un seul dossier, rassemblant les éléments du dépôt. Au sein du dépôt, tout l'historique est stocké et accessible rapidement. Si on souhaite travailler sur la dernière version des programmes (ou sur une ancienne version spécifique), il n'y a plus besoin de conserver les autres fichiers car ils sont dans l'historique du projet. Il est alors possible de choisir sur quelle version on veut travailler (la dernière commune à tout le monde, la sienne en train d'être développée, celle de l'année dernière, etc.).

## Travailler efficacement en équipe

Le deuxième avantage de la gestion de version représente une amélioration notable du travail en équipe sur des codes en commun. Que ce soit au sein d'un modèle cogéré (Ines, Destinie, etc.), de gros projets (Nautile) ou de chaînes de traitement récurrentes (enquête emploi, comptes trimestriels, etc.), la collaboration est courante lors des travaux statistiques. La gestion de version permet collaborer simplement et avec méthode. De façon organisée, elle permet de:

* travailler en parallèle et fusionner facilement du code
* partager une documentation des programmes grâce :
    + aux commentaires des modifications
    + à la possibilité d'une documentation commune et collaborative
* trouver rapidement des erreurs et en diffuser rapidement la
correction

**Exemple de détails d'une modification**
![](./pics/commit_Rstudio.png){width=100%} 

L'usage individuel, c'est-à-dire seul sur son projet, permet aussi de "travailler en équipe avec soi même" car il permet de retrouver des mois plus tards le contenu et le contexte des modifications. Cela est notamment précieux lors des changements de poste ou des travaux réguliers mais espacés dans le temps (par exemple, un mois par an chaque année).


## Améliorer la qualité des codes

Le fonctionnement du gestion de version, reposant sur l'archivage structuré des modifications et les commentaires les accompagnant, renforce la qualité des programmes informatiques. Ils sont plus documentés, plus riches et mieux structurés. 

Quand il s'agit de modèles statistiques, ou de chaînes de traitement statistique, constitués de nombreux programmes, la gestion de version permet :

* l'amélioration la qualité des modèles par des méta-données riches, 
* un gain de place pour stocker les historiques
* leur diffusion simplifiée et harmonisée. 

Lors de l'ouverture des modèles, leur diffusion publique correspond aux standards des communautés de logiciels libres et aux usages recommandés pour documenter des programmes informatiques. Cela permet aux utilisateurs ou aux agents découvrant des chaînes de traitement de mieux s'approprier les programmes.

## Usage quotidien : un exemple avec le modèle Ines

Le modèle Ines est co-développé par l'Insee et la Drees ainsi que la Cnaf depuis 2018. Sous licence libre, il est disponible en *open-source*. Il est organisé dans une forge qui regroupe le code, un wiki, une documentation, un forum et différents outils collaboratifs. Les utilisateurs y ont accès via la [plateforme Adullact](https://adullact.net/projects/ines-libre). Le dépôt regroupe donc les programmes, l'historique des modifications et les archives des différentes versions ('Ines 2018' par exemple).

Les chargés d'étude ont une copie locale du projet sur leur poste de travail. Les changements sont mis à jour et disponible en temps réel.

**Envoi d'une modification avec TortoiseSVN : commit**

![](./pics/commit_Ines.png){width=100%}   

**Historique d’un fichier ou dossier : log**
![](./pics/historique_Ines.png){width=100%}  

**Recherche efficace une erreur : blame**
![](./pics/blame_ines.png){width=100%}  


## Avec ou sans gestion de versions

Le tableau suivant compare les usages au temps (pré-historique ?) de la programmation sans gestion de version avec les modes de travail si on y a recours.

|                      |      Avant            |  Gestion de version  |
|:---------------------|----------------------:|---------------------:|
|Archivage             | à la main             | automatique          |
|Envoi de modification | mail, dossier partagé | code partagé         |
|Fusion de code        | copié-collé           | simple, sûr          |
|Versions du modèle    | dossiers archivés     | historique riche     |
|Gestion des erreurs   | à la main             | méthodique           |
|

En conclusion, que ce soit au sein d'un travail collaboratif en équipe ou sur ses propres projets individuels, notre temps est consacré à la programmation réellement utile. L'organisation du travail est efficace grâce :

* aux améliorations rapides des codes
* au partage efficace des tâches
* à la recherche puissante des erreurs
* à un archivage géré automatiquement avec des méta-données
* à des outils généralisés et documentés en ligne.

La gestion de version est donc le meilleur moyen de partager du code (entre équipes internes,
lors des changements de poste, pour l'archivage, lors de l'ouverture au libre, etc.). Ces outils viennent de l'informatique et de la création des logiciels et applications. Les traitements statistiques sont également des chaînes informatiques et sont donc pleinement adaptés pour être traités avec les outils de gestion de version.

# Des bases de GIT 

Les deux langages de gestion de version les plus répandus sont GIT et SVN. L'Insee a utilisé SVN pendant un temps mais privilégie GIT maintenant, en raison de plusieurs avantages.

GIT est open source, gratuit et très répandu. Ainsi, une vaste documentation est disponible en ligne ou les forums d'entraide de type 'stackoverflow' (voir par exemple le tag ['GIT'](https://stackoverflow.com/questions/tagged/git) ). Sur la plateforme 'github', la (page de tutoriel)[http://try.github.io/] regroupe différents supports. Des vidéos pédagogiques sont fournies sur (git-scm.com)[https://git-scm.com/videos]

Cependant, face au foisonnement des pratiques et des ressources en ligne, il est recommandé d'adopter et suivre les donnes pratiques pour chaque projet. Les configurations et les habitudes diffèrent et une solution proposée sur un forum ou dans un livre peut ne pas être adaptée dans notre cas précis. C'est l'objectif de ce support de rassembler les pratiques les plus courantes et présenter l'utilisation recommandée de la gestion de version avec R studio à l'Insee.

La genèse de Git correspond au noyau du système d'exploitation Linux qui gérait les patchs et les archives pendant les années 1990. À partir de 2005, Linus Torvalds, aussi inventeur de Linux, développe un successeur avec pour objectifs, la vitesse, la simplicité, la possibilité de développements en parallèle (les futures **branches**), le tout avec un usage compact des données. Depuis, son usage a largement dépassé celui de SVN.


SVN est dit centralisé alors que GIT est dit distribué. Cela signifie notamment que chaque collaborateur possède une copie en propre de l'ensemble du projet sur son poste de travail. Cela implique un avantage important de GIT en terme de sécurité des codes (qui risquent beaucoup moins d'être perdus) et la  rapidité des partages des modifications. En outre, contrairement à SVN pour lequel il faut être connecté à un serveur, il n'est pas besoin d'être connecté avec GIT et on peut travailler en local. Ainsi, on transmet ses modifications quand on le souhaite ou peut et cela facilite le travail distant.

Enfin, un des grands avantages pratiques de GIT est son intégration dans l’interface RStudio ainsi que dans les plateformes de forme Github et Gitlab (voir parties ci-après).


## Le B.A-BA
 

[documentation en ligne](https://git-scm.com/doc) `GIT` 

[livre en français](https://git-scm.com/book/fr/v2)

![](./pics/push_pull_Drees.png){width=100%} 

![](./pics/trois_états_fichier.png){width=100%} 

![](./pics/statut_fichiers.png){width=100%} 

Les programmes s’organisent sur un répertoire distant commun
(repository) et sont manipulés sur les postes indidivuels dans des
dossiers locaux (working directory).
Les trois commandes principales :

* diff : fichiers modifiés, ajoutés ou supprimés
* staging area puis commit : sélection et validation des modifications
* push et pull : mise à jour du local par rapport au distant (et
réciproquement)

Inspecter les modifications : git diff

Soumettre des modifications : git commit

Le message de validation est très important
– décrit brièvement les modifications contenues dans le commit
– importance de l’homogénéité des modifications contenues dans un commit
– à l’attention des autres développeurs

push 

pull


Il est possible d'éviter les conflits en amont en validant souvent les modifications ('commit') :

* par petits lots homogènes et en préférant peu de fichiers
* en communiquant avec les autres membres de l’équipe en disant sur quoi on travaille et en prévenant en cas de grosse modification
* Mettre à jour sa copie locale régulièrement, voire dès qu'on commencer à travailler sur un projet.

De manière générale, il ne faut pas avoir peur des conflits. Les outils sont faits pour les gérer avec rigueur et méthode (voir EXERCICE). Avec 'GIT', il est très rare de faire des bétises et on peut toujours réparer. Mais il n'est justement pas recommandé d'utiliser les commandes de la forme 'git push --force'.

## Les branches

Création de branches pour développer de longs projets, en
parallèle, sans perturber le dépôt commun : git branch
* Fusionner des projets (branches) : git merge

Fusion de branches

## Quelques éléments de GIT avancé

* Conserver des fichiers en privé : git ignore

Conseils de la Cnil : https://lincnil.github.io/Guide-RGPD-du-developpeur/ 

* Sauvegarder une version figée : git tag
En savoir plus : https://git-scm.com/.
 
retour en arrière dans l'historique

Qui a modifié en dernier une ligne donné dans un fichier donné ? git blame 

Rebasage
Réécriture de l'historique (usage non recommandé pour un usage non approfondi)


Pour aller plus loin :

https://romain-warnan.github.io/git-au-quotidien 
Supports du SNDI GIT base : http://formation-git-sndi-lille.pages.innovation.insee.eu/cours/#/


## Gitlab, aperçu de la plateforme de partage de code 

Gitlab est une plateforme facilitant l’utilisation de git, qui permet de travailler de façon collaborative dans le développement informatique, par équipe ou non, pour un code qui évolue constamment. Un réseau social du code

Principales fonctionnalités :

Inspecter un dépôt distant : onglet branches, commits etc

[documentation](https://docs.gitlab.com/ee/user/index.html)  `GitLab`

cf. Drees : groupes publics et privé, profils, pages projet etc.

![](./pics/page_Drees_gitlab.png){width=100%} 

![](./pics/projet_gitlab.png){width=100%} 

* Explorations du code

* Tickets

* Fusion de branches : MR et merge en pratique (exemples des PR avec commentaires etc.)

 à éviter pour un usage néophyte :  à éviter pour un usage néophyte
 si vous avez peur de faire une bêtise, commencez par faire une copie locale de votre clone

rebase
push force


# Bonnes pratiques de GIT et GITLab 

Dans cette partie, nous allons adopter un fil rouge en créant un document collaboratif commun et en pratiquant par des exercices les principales situations d'un statisticien qui travaille avec R et GIT via RStudio et GitLab. 


## Pré-requis pour l'organisation du travail collaboratif

- vous devez identifier les responsables de la maintenance du projet. Dans `GitLab`, c'est facile, c'est le rôle de _Maintener_ (droits d'écriture sur `master`)
- chaque mainteneur a une responsabilité identique et élevée : n'accordez pas les droits de mainteneur sur votre repo à la légère, vous pourriez le regretter
- c'est au(x) mainteneur(s) du repo de définir les règles d'organisation du travail
- idéalement, ces règles doivent être précisément décrites dans un fichier nommé `CONTRIBUTING.md` placé à la racine du projet
- il est essentiel que chaque personne qui contribue au projet se conforme à ces règles
- `git` est un outil extrêmement puissant et flexible, adaptable à tout type d'organisation du travail. Dès lors, les problèmes que vous rencontrerez ne seront pas liés à `git` mais à une mauvaise définition de l'organisation du travail ou bien à son non respect par les mainteneurs. 
- d'expérience, si vous n'avez pas réfléchi à l'organisation du travail, il est à peu près certain que vous rencontrerez des problèmes. Des difficultés peuvent en particulier apparaître dans une équipe dont personne n'aurait d'expérience avec `git`
- vous devez savoir qu'il y a plusieurs méthodes de travail avec `git`. Vous pourrez trouvez des dizaines d'articles et d'ouvrages sur ce sujet dont chacun prétend avoir trouvé la meilleure organisation du travail. Ne lisez pas trop ces livres et articles sinon vous serez perdus (un peu comme avec les magazines destinés aux jeunes parents...)

Cependant, vous devez savoir que des "habitudes" se sont imposées dans la communauté R, essentiellement au travers des collaborations sur la plateforme GitHub (GitLab fonctionne de la même façon mais est open source contrairement à GitHub). Au fur et à mesure des collaborations, une forme de "norme sociale" s'est peu à peu imposée. Nous allons vous décrire ces habitudes. Cela vous donnera une première base, autant de points de repères. Vous pourrez ainsi contribuer à vos packages préférés sur GitHub. Au fur et à mesure de vos projets et quand vous aurez acquis une certaine maîtrise de `git`, vous adapterez certainement ces règles à vos besoins. Cela n'est absolument pas gênant... à partir du moment où vous comprenez ce que vous faites.


On propose une synthèse des usages de `git` dans la communauté R, adaptés à la configuration à l'Insee : AUS pour commencer (puis à la fin donner les autres usages.)

## GIT en local

Exercice : staging
Modifier un fichier

Exercice : commit
Valider cette modification dans votre dépôt local

Exercice : push
Envoyer cette modification au dépôt commun

Exercice : pull
Récupérer les modifications du dépôt commun

Exercice : branch
Créer une branche et la modifier.

Excercice : gitignore
Ajouter les fichiers .pdf etc. dans le gitignore

gitignore : pas les résultats (exemple des markdowns volumineux), pas les données, pas d'informations personnelles (configuration).
ce n'est pas un drive / dropbox.


Voici quelques usages couramment répandus, ceux qu'on observe le plus souvent. Nous ne prétendons pas que tout le monde respecte toutes ces règles mais voici les "patterns" fréquemment observés. Comme il a été indiqué, ces règles ne sont pas les "meilleures". Vous trouverez donc toujours quelqu'un pour indiquer que telle ou telle règle n'est pas nécessaire, qu'on peut faire autrement, qu'une autre est bien meilleure... 

Même si elles sont écrites de façon impérative, conservez du recul. Cependant, si vous les adoptez, tout se passera bien.

## Ouvrir et organiser les issues

Avant de travailler, vous devez ouvrir des issues. Au début de votre projet, ce seront des fonctionnalités (en anglais, _features_). Au bout d'un moment, vos issues seront également des bugs constatés.

Ces issues seront fermées au fur et à mesure que les fonctionnalités seront implémentées ou bien que vous aurez abandonné vos idées. Utilisez les labels pour classer vos issues. Vous pouvez les affecter à une personne en particulier, fixer une date de rendu, etc.

EXERCICE : ouvrir et assigner une issue à votre voisin. Répondre à celle de votre voisin et clore celle que vous avez initiée. 

## Le rôle de `master`

La branche `master` est la branche principale. Elle se doit d'être "propre". On ne pousse pas des travaux non aboutis sur `master`, c'est très mal vu. Avec l'intégration continue, elle se doit d'être en succès. 

Peut-on pousser directement sur `master` ? oui, pour des petites corrections, des modifications mineures dont vous êtes certains qu'elles vont fonctionner. Mais sachez que dans le cadre de projets sensibles, c'est strictement interdit. N'ayez pas peur de fixer comme règle l'interdiction de pousser sur master, cela obligera l'équipe projet à travailler très professionnellement (ça fera peut-être râler certains coéquipiers mais c'est pour la bonne cause).

Au moindre doute, créez une branche.

## Les branches

Les branches sont utilisées pour des travaux significatifs :

- vous travaillez seul sur une tâche qui va vous prendre plusieurs heures ou jours de travail (vous ne devez pas pousser sur master des travaux non aboutis)
- vous travaillez sur une fonctionnalité nouvelle et vous souhaiterez recueillir l'avis de vos collègues avant de modifier `master`
- vous n'êtes pas certain de réussir vos modifications "du premier coup"

**Toutes les branches sont publiées, le rebase est interdit. Le push force est également interdit.** (carton rouge)

**Tous les merges dans master doivent se faire par l'intermédiaire d'une merge request dans GitLab**. En effet, il est très mal vu de merger une branche dans master localement (carton rouge).

Comment nommer les branches ? Là encore, il y a énormément de conventions différentes. Une fréquemment observée est :

- pour les nouvelles fonctionnalités : `feature/nouvelle-fonctionnalite` où `nouvelle-fontionnalite` est un nom court résumant la fonctionnalité
- pour les corrections de bug : `issue-num` où `num` est le numéro de l'issue

N'hésitez pas à aller encore plus loin dans la normalisation : c'est pour la bonne cause !

EXERCICE : créer une branche avec votre voisin, commit, push, pull

## Ouvrir des merge requests

Les merges requests sont sans doute la fonctionnalité la plus pratique.

Vous ouvrez une merge request :

- donnez un titre explicite
- donnez des détails dans le message
- dans le corps du message, ajoutez `close #xx` où `xx` est le numéro de l'issue décrivant la fonctionnalité que la merge request implémente. Lorsque la merge request sera fusionnée, l'issue sera automatiquement fermée et un lien sera créé entre l'issue et la merge request. Cela vous permettra de comprendre, plusieurs mois ou années plus tard comment et pourquoi telle ou telle fonctionnalité à été implémentée

Une fois une merge request ouverte, sollicitez une relecture. En effet, personne (même les superstars de la programmation) n'est à l'abri d'une erreur. 

Les merge requests doivent également modifier le fichier `NEWS.md`, de la façon suivante :

```markdown
# Version 0.4

## Nouvelles fonctionnalités

- La fonction `show_map()` permet d'afficher une carte (#xx et !yy).

## Corrections de bugs

- La fonction `compute_map()` renvoie une erreur si la projection n'est pas Lambert-93 (#ww et #zz).
``` 

Dans l'exemple ci-dessus, les chiffres précédés de `!` font référence aux numéros des merges requests.  
Les chiffres précédés de `#` font références aux issues.

EXERCICE : créer une MR proprement avec GitLab (indications)

## Contribuer aux merge requests

**Les merge requests sont des espaces de discussion**. Vous pouvez commenter une proposition de modification en particulier ou bien suggérer une modification.

Lorsqu'elles sont acceptées, les suggestions sont appliquées au moyen d'un commit. Cela permet une parfaite traçabilité des modifications.

EXERCICE : Choisissez une autre MR et contribuez-y via GitLab.

## Fusionner les merge requests

C'est la responsabilité des mainteneurs : seuls les mainteneurs peuvent merger dans master. Il leur appartient de veiller à la bonne qualité des merge requests.

Question : squash and merge ou pas ?  
Là, vous devrez faire preuve de discernement. L'habitude est de faire des squash and merge (pratique la plus largement répandue). Cependant, il peut y avoir des cas où vous préférerez conserver l'historique des commits (c'est plus rare). Très franchement, ce sujet n'est pas le plus important.

## Résoudre les conflits

Si vous adoptez les règles précédentes, master sera surtout modifié via des merge requests. Vous ne devriez donc jamais avoir de conflits sur master.

Tous les conflits devraient donc survenir dans les branches. Les merge requests en conflit sont impossibles à merger. Il n'y a donc pas de possibilité de commettre un erreur par mégarde (c'est la raison pour laquelle il est interdit de merger dans master localement).

Si votre branche est en conflit, **le conflit doit être résolu dans la branche et pas dans master**. Voici la marche à suivre :

- appliquez le conseil de survie : faites une copie de sauvegarde de votre clone (avec l'expérience, vous pourrez vous passer de cette étape)
- dans votre clone, placez vous sur la branche en question `git checkout nom-de-la-branche`
- mergez master dans la branche `git merge master`
- résolvez les conflits
- finalisez le commit de merge
- poussez vers GitLab

Rappel : **Il est interdit de faire l'inverse (merger localement la branche dans master)**

Une référence sur GitHub : https://happygitwithr.com/ 

EXERCICE : ouvrir une MR, l'assigner, la résoudre sur GitLab
Usage des issues et ToDo

EXERCICE : comment on peut contribuer à un repo pour lequel on n'a pas les droits en écriture à l'aide d'un fork

# Configurer un projet GIT avec Rstudio à l'Insee


vidéo installation du SNDI : http://formation-git-sndi-lille.pages.innovation.insee.eu/installation-git/ 

configuration GIT  :https://git.stable.innovation.insee.eu/formation-git-sndi-lille/installation-git

remote SSH via la plateforme innovation sur AUS.

présentation HTTPS sur github.com et giltlab.com ici.


    